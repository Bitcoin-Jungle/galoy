type Query {
  allLevels: [AccountLevel!]!
  accountDetailsByUserPhone(phone: Phone!): Account!
  accountDetailsByUsername(username: Username!): Account!
  transactionById(id: ID!): Transaction
  transactionsByHash(hash: PaymentHash!): [Transaction]
  lightningInvoice(hash: PaymentHash!): LightningInvoice!
  lightningPayment(hash: PaymentHash!): LightningPayment!
}

enum AccountLevel {
  ONE
  TWO
}

type Account {
  id: ID!
  username: Username
  level: AccountLevel!
  status: AccountStatus!
  title: String
  owner: User!
  coordinates: Coordinates
  createdAt: Timestamp!
}

"""
Unique identifier of a user
"""
scalar Username

enum AccountStatus {
  LOCKED
  ACTIVE
}

type User {
  id: ID!
  phone: Phone!
  language: Language!
  defaultAccount: Account!
  createdAt: Timestamp!
}

"""
Phone number which includes country code
"""
scalar Phone

scalar Language

"""
Timestamp field, serialized as Unix time (the number of seconds since the Unix epoch)
"""
scalar Timestamp

type Coordinates {
  longitude: Float!
  latitude: Float!
}

"""
Give details about an individual transaction.
Galoy have a smart routing system which is automatically
settling intraledger when both the payer and payee use the same wallet
therefore it's possible the transactions is being initiated onchain
or with lightning but settled intraledger.
"""
type Transaction {
  id: ID!

  """
  From which protocol the payment has been initiated.
  """
  initiationVia: InitiationVia!

  """
  To which protocol the payment has settled on.
  """
  settlementVia: SettlementVia!

  """
  Amount of sats paid by the user.
  """
  settlementAmount: SatAmount!
  settlementFee: SatAmount!

  """
  Price in USDCENT/SATS at time of settlement.
  """
  settlementPrice: Price!
  direction: TxDirection!
  status: TxStatus!
  memo: Memo
  createdAt: Timestamp!
}

union InitiationVia = InitiationViaIntraLedger | InitiationViaLn | InitiationViaOnChain

type InitiationViaIntraLedger {
  counterPartyWalletId: WalletId
  counterPartyUsername: Username
}

"""
Unique identifier of a user
"""
scalar WalletId

type InitiationViaLn {
  paymentHash: PaymentHash!
}

scalar PaymentHash

type InitiationViaOnChain {
  address: OnChainAddress!
}

"""
An address for an on-chain bitcoin destination
"""
scalar OnChainAddress

union SettlementVia = SettlementViaIntraLedger | SettlementViaLn | SettlementViaOnChain

type SettlementViaIntraLedger {
  counterPartyWalletId: WalletId

  """
  Settlement destination: Could be null if the payee does not have a username
  """
  counterPartyUsername: Username
}

type SettlementViaLn {
  paymentSecret: LnPaymentSecret
}

scalar LnPaymentSecret

type SettlementViaOnChain {
  transactionHash: OnChainTxHash!
}

scalar OnChainTxHash

"""
(Positive) Satoshi amount (i.g. quiz earning)
"""
scalar SatAmount

"""
Price amount expressed in base/offset. To calculate, use: `base / 10^offset`
"""
type Price {
  base: SafeInt!
  offset: Int!
  currencyUnit: ExchangeCurrencyUnit!
  formattedAmount: String!
}

"""
Non-fractional signed whole numeric value between -(2^53) + 1 and 2^53 - 1
"""
scalar SafeInt

enum ExchangeCurrencyUnit {
  BTCSAT
  USDCENT
}

enum TxDirection {
  SEND
  RECEIVE
}

enum TxStatus {
  PENDING
  SUCCESS
  FAILURE
}

"""
Text field in a lightning payment transaction
"""
scalar Memo

type LightningInvoice {
  createdAt: Timestamp!
  confirmedAt: Timestamp
  description: String!
  expiresAt: Timestamp
  isSettled: Boolean!
  received: SatAmount!
  request: LnPaymentRequest
  secret: LnPaymentSecret!
}

"""
BOLT11 lightning invoice payment request with the amount included
"""
scalar LnPaymentRequest

type LightningPayment {
  status: LnPaymentStatus
  roundedUpFee: SatAmount
  createdAt: Timestamp
  confirmedAt: Timestamp
  amount: SatAmount
  secret: LnPaymentSecret
  request: LnPaymentRequest
  destination: LnPubkey
}

enum LnPaymentStatus {
  PENDING
  FAILED
  SETTLED
}

scalar LnPubkey

type Mutation {
  userRequestAuthCode(input: UserRequestAuthCodeInput!): SuccessPayload!
  userLogin(input: UserLoginInput!): AuthTokenPayload!
  accountUpdateLevel(input: AccountUpdateLevelInput!): AccountDetailPayload!
  accountUpdateStatus(input: UserUpdateStatusInput!): AccountDetailPayload!
  businessUpdateMapInfo(input: BusinessUpdateMapInfoInput!): AccountDetailPayload!
}

type SuccessPayload {
  errors: [Error!]!
  success: Boolean
}

interface Error {
  message: String!
  path: [String]
}

input UserRequestAuthCodeInput {
  phone: Phone!
}

type AuthTokenPayload {
  errors: [Error!]!
  authToken: AuthToken
}

"""
An authentication code valid for a single use
"""
scalar AuthToken

input UserLoginInput {
  phone: Phone!
  code: OneTimeAuthCode!
}

"""
An authentication code valid for a single use
"""
scalar OneTimeAuthCode

type AccountDetailPayload {
  errors: [Error!]!
  accountDetails: Account
}

input AccountUpdateLevelInput {
  uid: ID!
  level: AccountLevel!
}

input UserUpdateStatusInput {
  uid: ID!
  status: AccountStatus!
}

input BusinessUpdateMapInfoInput {
  username: Username!
  title: String!
  longitude: Float!
  latitude: Float!
}
